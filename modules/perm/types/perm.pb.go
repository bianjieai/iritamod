// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: perm/perm.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	strconv "strconv"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Role represents a role
type Role int32

const (
	// ROOT_ADMIN defines the root admin role index.
	RoleRootAdmin Role = 0
	// PERM_ADMIN defines the permission admin role index.
	RolePermAdmin Role = 1
	// BLACKLIST_ADMIN defines the blacklist admin role index.
	RoleBlacklistAdmin Role = 2
	// NODE_ADMIN defines the node admin role index.
	RoleNodeAdmin Role = 3
	// PARAM_ADMIN defines the param admin role index.
	RoleParamAdmin Role = 4
	// POWER_USER defines the power user role index.
	RolePowerUser Role = 5
	// RELAYER_USER defines the relayer user role index.
	RoleRelayerUser Role = 6
	// ID_ADMIN defines the identity admin role index.
	RoleIDAdmin Role = 7
	// BASE_M1_ADMIN defines the base M1 admin role index.
	RoleBaseM1Admin Role = 8
)

var Role_name = map[int32]string{
	0: "ROOT_ADMIN",
	1: "PERM_ADMIN",
	2: "BLACKLIST_ADMIN",
	3: "NODE_ADMIN",
	4: "PARAM_ADMIN",
	5: "POWER_USER",
	6: "RELAYER_USER",
	7: "ID_ADMIN",
	8: "BASE_M1_ADMIN",
}

var Role_value = map[string]int32{
	"ROOT_ADMIN":      0,
	"PERM_ADMIN":      1,
	"BLACKLIST_ADMIN": 2,
	"NODE_ADMIN":      3,
	"PARAM_ADMIN":     4,
	"POWER_USER":      5,
	"RELAYER_USER":    6,
	"ID_ADMIN":        7,
	"BASE_M1_ADMIN":   8,
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bb77ba30a3a45e51, []int{0}
}

// PubKey represents a public key along with the corresponding algorithm
type RoleSet struct {
	Roles []Role `protobuf:"varint,1,rep,packed,name=roles,proto3,enum=iritamod.perm.Role" json:"roles,omitempty"`
}

func (m *RoleSet) Reset()         { *m = RoleSet{} }
func (m *RoleSet) String() string { return proto.CompactTextString(m) }
func (*RoleSet) ProtoMessage()    {}
func (*RoleSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_bb77ba30a3a45e51, []int{0}
}
func (m *RoleSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleSet.Merge(m, src)
}
func (m *RoleSet) XXX_Size() int {
	return m.Size()
}
func (m *RoleSet) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleSet.DiscardUnknown(m)
}

var xxx_messageInfo_RoleSet proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("iritamod.perm.Role", Role_name, Role_value)
	proto.RegisterType((*RoleSet)(nil), "iritamod.perm.RoleSet")
}

func init() { proto.RegisterFile("perm/perm.proto", fileDescriptor_bb77ba30a3a45e51) }

var fileDescriptor_bb77ba30a3a45e51 = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0xd2, 0x4d, 0x8f, 0x93, 0x40,
	0x18, 0x07, 0x70, 0xd8, 0xed, 0xbe, 0x64, 0x76, 0xbb, 0xac, 0xac, 0x31, 0x86, 0xc4, 0x11, 0x35,
	0x1a, 0x5f, 0x12, 0x70, 0xf5, 0xb6, 0x37, 0x10, 0x0e, 0xc4, 0x02, 0xcd, 0xe0, 0xc6, 0xe8, 0xa5,
	0x99, 0x2e, 0x93, 0x3a, 0x0a, 0x3b, 0xcd, 0x40, 0x63, 0xfa, 0x0d, 0x0c, 0x27, 0xbf, 0x00, 0x89,
	0x89, 0x3d, 0x78, 0xf4, 0x63, 0xf4, 0xd8, 0xa3, 0xc7, 0xda, 0x5e, 0xfc, 0x18, 0x66, 0x78, 0x09,
	0x7a, 0x21, 0x64, 0xf8, 0xf1, 0xff, 0x3f, 0xe4, 0x01, 0x28, 0x53, 0xc2, 0x53, 0x53, 0x5c, 0x8c,
	0x29, 0x67, 0x39, 0x53, 0xfb, 0x94, 0xd3, 0x1c, 0xa7, 0x2c, 0x36, 0xc4, 0xa1, 0x76, 0x73, 0xc2,
	0x26, 0xac, 0x7a, 0x62, 0x8a, 0xbb, 0x1a, 0xdd, 0xbf, 0x00, 0x07, 0x88, 0x25, 0x24, 0x22, 0xb9,
	0xfa, 0x04, 0xec, 0x71, 0x96, 0x90, 0xec, 0xb6, 0xac, 0xef, 0x3e, 0x3e, 0x79, 0x71, 0x66, 0xfc,
	0xf7, 0xbe, 0x21, 0x18, 0xaa, 0xc5, 0x45, 0xef, 0xcf, 0xb7, 0xbb, 0xf2, 0xd3, 0xf5, 0x0e, 0xe8,
	0x89, 0x53, 0xf5, 0x1e, 0x00, 0x28, 0x0c, 0xdf, 0x8c, 0x2c, 0xc7, 0xf7, 0x82, 0x53, 0x49, 0xbb,
	0x51, 0x94, 0x7a, 0xbf, 0xf2, 0x8c, 0xe5, 0x56, 0x9c, 0xd2, 0x6b, 0x41, 0x86, 0x2e, 0xf2, 0x1b,
	0x22, 0x77, 0x64, 0x48, 0x78, 0x5a, 0x93, 0x67, 0x40, 0xb1, 0x07, 0xd6, 0xab, 0xd7, 0x03, 0x2f,
	0x6a, 0xa3, 0x76, 0xb4, 0x5b, 0x45, 0xa9, 0xab, 0xc2, 0xd9, 0x09, 0xbe, 0xfa, 0x94, 0xd0, 0xac,
	0xcb, 0x0b, 0x42, 0xc7, 0x6d, 0xdc, 0x6e, 0x97, 0x17, 0xb0, 0x98, 0xd4, 0xe4, 0x01, 0x38, 0x1a,
	0x5a, 0xc8, 0x6a, 0x3b, 0x7b, 0x9a, 0x5a, 0x94, 0xfa, 0x49, 0xd5, 0x89, 0x39, 0x4e, 0xbb, 0xb9,
	0xc2, 0xb7, 0x2e, 0x1a, 0x5d, 0x46, 0x2e, 0x3a, 0xdd, 0xfb, 0x67, 0x2e, 0xf6, 0x99, 0xf0, 0xcb,
	0x8c, 0x70, 0xf5, 0x21, 0x38, 0x46, 0xee, 0xc0, 0x7a, 0xd7, 0xa2, 0x7d, 0xed, 0xac, 0x28, 0x75,
	0xa5, 0xfa, 0x3e, 0x92, 0xe0, 0x79, 0xc3, 0xee, 0x80, 0x43, 0xcf, 0x69, 0xba, 0x0e, 0x34, 0xa5,
	0x28, 0xf5, 0x23, 0x41, 0x3c, 0xa7, 0x2e, 0x7a, 0x04, 0xfa, 0xb6, 0x15, 0xb9, 0x23, 0xff, 0xbc,
	0x31, 0x87, 0x5d, 0x8c, 0x8d, 0x33, 0xe2, 0x9f, 0x57, 0x4e, 0x3b, 0xfe, 0xf2, 0x1d, 0x4a, 0x3f,
	0x16, 0x50, 0xfa, 0xb9, 0x80, 0xb2, 0x1d, 0x2c, 0x7f, 0x43, 0x69, 0xb9, 0x81, 0xf2, 0x6a, 0x03,
	0xe5, 0xf5, 0x06, 0xca, 0x5f, 0xb7, 0x50, 0x5a, 0x6d, 0xa1, 0xf4, 0x6b, 0x0b, 0xa5, 0xf7, 0xcf,
	0x27, 0x34, 0xff, 0x30, 0x1b, 0x1b, 0x57, 0x2c, 0x35, 0xc7, 0x14, 0x5f, 0x7f, 0xa4, 0x04, 0x53,
	0xb3, 0x5d, 0x9b, 0x99, 0xb2, 0x78, 0x96, 0x90, 0xac, 0xfa, 0x27, 0xcc, 0x7c, 0x3e, 0x25, 0xd9,
	0x78, 0xbf, 0xda, 0xfa, 0xcb, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd2, 0xcc, 0x3a, 0xe5, 0x2d,
	0x02, 0x00, 0x00,
}

func (x Role) String() string {
	s, ok := Role_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *RoleSet) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleSet)
	if !ok {
		that2, ok := that.(RoleSet)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Roles) != len(that1.Roles) {
		return false
	}
	for i := range this.Roles {
		if this.Roles[i] != that1.Roles[i] {
			return false
		}
	}
	return true
}
func (m *RoleSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Roles) > 0 {
		dAtA2 := make([]byte, len(m.Roles)*10)
		var j1 int
		for _, num := range m.Roles {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPerm(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPerm(dAtA []byte, offset int, v uint64) int {
	offset -= sovPerm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RoleSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Roles) > 0 {
		l = 0
		for _, e := range m.Roles {
			l += sovPerm(uint64(e))
		}
		n += 1 + sovPerm(uint64(l)) + l
	}
	return n
}

func sovPerm(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPerm(x uint64) (n int) {
	return sovPerm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RoleSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPerm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Role
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPerm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Role(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Roles = append(m.Roles, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPerm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPerm
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPerm
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Roles) == 0 {
					m.Roles = make([]Role, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Role
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPerm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Role(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Roles = append(m.Roles, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPerm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPerm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPerm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPerm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPerm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPerm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPerm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPerm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPerm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPerm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPerm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPerm = fmt.Errorf("proto: unexpected end of group")
)
